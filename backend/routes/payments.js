const express = require('express');
const { protect } = require('../middleware/auth');
const { successResponse, errorResponse } = require('../utils/helpers');
const stripeService = require('../utils/stripeService');
const Reservation = require('../models/Reservation');
const Payment = require('../models/Payment');
const Invoice = require('../models/Invoice');
const PromoCode = require('../models/PromoCode');
const User = require('../models/User');
const { sendPaymentConfirmationEmail } = require('../utils/emailService');
const whatsappService = require('../utils/whatsappService');
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

const router = express.Router();

/**
 * Helper function to record revenue (Invoice & Payment)
 */
async function recordRevenue(reservation, paymentData) {
  const Invoice = require('../models/Invoice');
  const Payment = require('../models/Payment');

  try {
    console.log('üí∞ Recording revenue for reservation:', reservation._id);

    // Check if invoice already exists
    const existingInvoice = await Invoice.findOne({ reservation: reservation._id });
    if (existingInvoice) {
      console.log('‚ö†Ô∏è Invoice already exists for reservation:', reservation._id);
      return true;
    }

    // 1. Create Invoice
    const invoice = new Invoice({
        // invoiceId will be generated by pre-validate hook
        user: reservation.user,
        reservation: reservation._id,
        clientName: reservation.touristName || 'Guest',
        clientEmail: reservation.email,
        clientPhone: reservation.phone,
        clientNationality: reservation.nationality || 'Unknown',
        hotelName: reservation.hotel.name,
        hotelAddress: reservation.hotel.address || reservation.hotel.name,
        amount: parseFloat(paymentData.amount) || reservation.totalPrice,
        currency: paymentData.currency || reservation.currency,
        status: 'paid',
        paymentStatus: 'paid',
        paymentDetails: {
          paidAt: new Date(),
          paymentMethod: 'kashier',
          transactionId: paymentData.sessionId
        }
    });

    await invoice.save();

    // 2. Create Payment
    const payment = new Payment({
        invoice: invoice._id,
        user: reservation.user,
        amount: invoice.amount,
        currency: invoice.currency,
        paymentMethod: 'kashier',
        status: 'completed',
        transactionId: paymentData.sessionId,
        merchantOrderId: paymentData.orderId,
        metadata: {
          reservationId: reservation._id,
          kashierOrderId: paymentData.orderId
        },
        processedAt: new Date()
    });
    await payment.save();

    console.log('‚úÖ Revenue recorded: Invoice & Payment created', invoice._id);
    return true;
  } catch (error) {
    console.error('‚ùå Failed to record revenue:', error);
    return false;
  }
}

/**
 * Helper function to create RateHawk booking after payment confirmation
 */
async function createRateHawkBooking(reservationParam, orderId) {
  const rateHawkService = require('../utils/RateHawkService');
  const Reservation = require('../models/Reservation');

  try {
    // Reload reservation from database to get latest data
    const reservation = await Reservation.findById(reservationParam._id);
    if (!reservation) {
      console.error('‚ùå Reservation not found');
      return;
    }

    const matchHash = reservation.hotel.rateHawkMatchHash;

    if (!matchHash) {
      console.error('‚ùå No match hash found in reservation');
      await Reservation.findByIdAndUpdate(reservation._id, { ratehawkStatus: 'hash_missing' });
      return;
    }

    // Check if we already have a book_hash from the prebook step (new flow)
    let bookHash = reservation.hotel.rateHawkBookHash;
    let depositAmount, depositCurrency;

    if (bookHash) {
      console.log('‚úÖ Found existing book_hash from prebook step:', bookHash);

      // Use stored prebook payment details if available
      depositAmount = reservation.hotel.prebookPaymentAmount;
      depositCurrency = reservation.hotel.prebookPaymentCurrency;

      if (depositAmount && depositCurrency) {
         console.log(`üí∞ Using pre-booked payment details: ${depositAmount} ${depositCurrency}`);
      }
    } else {
      // Fallback to old flow: Prebook now (if not done before payment)
      console.log('üîÑ Step 1: Prebooking (Legacy Flow)...');
      const prebookResult = await rateHawkService.prebook(matchHash, 'en');

      if (!prebookResult.success || !prebookResult.book_hash) {
        console.error('‚ùå Prebook failed');
        await Reservation.findByIdAndUpdate(reservation._id, { ratehawkStatus: 'prebook_failed' });
        return;
      }

      bookHash = prebookResult.book_hash;

      // extract details from fresh prebook
      const prebookPaymentType = prebookResult.data?.hotels?.[0]?.rates?.[0]?.payment_options?.payment_types?.[0];
      depositAmount = prebookPaymentType?.amount || Number(reservation.totalPrice).toFixed(2);
      depositCurrency = prebookPaymentType?.currency_code || reservation.currency || 'USD';

      console.log('‚úÖ Prebook successful');
    }

    // Step 2: Create booking form
    console.log('üìù Step 2: Creating booking form...');
    const bookingFormResult = await rateHawkService.createBooking(bookHash, {
      partner_order_id: orderId,
      user_ip: '0.0.0.0',
      language: 'en'
    });

    if (!bookingFormResult.success) {
      if (bookingFormResult.sandbox_mode) {
        console.log('‚ö†Ô∏è Sandbox mode - simulating booking');
        await Reservation.findByIdAndUpdate(reservation._id, {
          status: 'confirmed',
          ratehawkOrderId: orderId, // Use our internal ID as reference
          ratehawkStatus: 'sandbox'
        });

        // Send confirmation email
        try {
          await sendPaymentConfirmationEmail({
            email: reservation.email,
            name: reservation.touristName,
            invoice: { hotelName: reservation.hotel.name, total: reservation.totalPrice },
            payment: { status: 'completed' }
          });
        } catch (emailError) {
          console.error('Email error:', emailError.message);
        }
        return;
      }

      await Reservation.findByIdAndUpdate(reservation._id, { ratehawkStatus: 'booking_form_failed' });
      return;
    }

    // NOTE: Test hotel will now go through the full booking flow for certification
    // This logic was previously skipping the booking for test hotels - now removed

    // Ensure we have payment details for startBooking
    if (!depositAmount || !depositCurrency) {
       depositAmount = Number(reservation.totalPrice).toFixed(2);
       depositCurrency = reservation.currency || 'USD';
    }

    console.log('üí∞ Final Payment details for booking:');
    console.log(`   Deposit Amount: ${depositAmount} ${depositCurrency}`);

    // Step 3: Start booking with guest details
    console.log('üöÄ Step 3: Starting booking...');
    const nameParts = (reservation.touristName || 'Guest User').split(' ');
    const firstName = nameParts[0] || 'Guest';
    const lastName = nameParts.slice(1).join(' ') || 'User';

    await rateHawkService.startBooking(orderId, {
      user: {
        email: reservation.email,
        phone: reservation.phone,
        comment: reservation.specialRequests || ''
      },
      supplier_data: {
        first_name_original: firstName,
        last_name_original: lastName,
        phone: reservation.phone,
        email: reservation.email
      },
      rooms: [{
        guests: [{ first_name: firstName, last_name: lastName }]
      }],
      language: 'en',
      payment_type: {
        type: 'deposit',
        amount: depositAmount,  // Use prebook amount (USD)
        currency_code: depositCurrency  // Use prebook currency (USD)
      }
    });

    // Step 4: Poll for booking status
    console.log('‚è≥ Step 4: Checking booking status...');
    let bookingStatus;
    let attempts = 0;
    const maxAttempts = 6; // Reduced from 10 to 6

    while (attempts < maxAttempts) {
      await new Promise(resolve => setTimeout(resolve, 3000)); // Increased from 2s to 3s
      bookingStatus = await rateHawkService.checkBookingStatus(orderId);
      console.log(`   Status check ${attempts + 1}/${maxAttempts}:`, bookingStatus.status);

      if (bookingStatus.status === 'ok' || bookingStatus.status === 'error') {
        break;
      }
      attempts++;
    }

    if (bookingStatus.status === 'ok') {
      console.log('‚úÖ RateHawk booking confirmed!');
      await Reservation.findByIdAndUpdate(reservation._id, {
        status: 'confirmed',
        ratehawkOrderId: orderId, // Our partner order ID
        ratehawkSystemOrderId: bookingStatus.order_id, // RateHawk's system order ID
        ratehawkStatus: 'confirmed'
      });

      // Send confirmation email
      try {
        await sendPaymentConfirmationEmail({
          email: reservation.email,
          name: reservation.touristName,
          invoice: {
            hotelName: reservation.hotel.name,
            total: reservation.totalPrice,
            currency: reservation.currency
          },
          payment: { status: 'completed' }
        });
      } catch (emailError) {
        console.error('Email error:', emailError.message);
      }

      // Send WhatsApp notification
      try {
        await whatsappService.sendBookingConfirmation({
          touristName: reservation.touristName,
          phone: reservation.phone,
          hotel: { name: reservation.hotel.name },
          checkIn: reservation.checkInDate,
          checkOut: reservation.checkOutDate
        }, { status: 'completed', amount: reservation.totalPrice });
      } catch (whatsappError) {
        console.error('WhatsApp error:', whatsappError.message);
      }
    } else if (bookingStatus.status === 'error') {
      // Check if this is a test hotel
      console.log('üîç Booking failed with error status. Full Details:', JSON.stringify(bookingStatus, null, 2));
      console.log('üîç Hotel ID:', reservation.hotel.hotelId);

      if (reservation.hotel.hotelId === 'test_hotel_do_not_book' || reservation.hotel.name === 'Test Hotel Do Not Book') {
        // Test hotel - treat as sandbox mode
        console.log('‚ö†Ô∏è Test hotel detected - treating as successful sandbox booking');
        await Reservation.findByIdAndUpdate(reservation._id, {
          status: 'confirmed',
          ratehawkOrderId: orderId,
          ratehawkStatus: 'sandbox'
        });

        // Send confirmation email
        try {
          await sendPaymentConfirmationEmail({
            email: reservation.email,
          name: reservation.touristName,
          invoice: {
            hotelName: reservation.hotel.name,
            total: reservation.totalPrice,
            currency: reservation.currency
          },
          payment: { status: 'completed' }
        });
      } catch (emailError) {
        console.error('Email error:', emailError.message);
      }
    } else {
      console.error('‚ùå RateHawk booking failed (non-test hotel):', bookingStatus.status);
      await Reservation.findByIdAndUpdate(reservation._id, { ratehawkStatus: 'booking_failed' });
    }
    } else {
      console.error('‚ùå RateHawk booking failed:', bookingStatus.status);
      await Reservation.findByIdAndUpdate(reservation._id, { ratehawkStatus: 'booking_failed' });
    }

  } catch (error) {
    console.error('‚ùå RateHawk booking error:', error.message);
    await Reservation.findByIdAndUpdate(reservation._id, { ratehawkStatus: 'error' });
  }
}

/**
 * Create payment session for invoice
 * POST /api/payments/create-session
 */
router.post('/create-session', protect, async (req, res) => {
  try {
    const { invoiceId } = req.body;

    if (!invoiceId) {
      return errorResponse(res, 'Invoice ID is required', 400);
    }

    const result = await stripeService.createCheckoutSession(invoiceId, req.user.id);

    successResponse(res, {
      sessionId: result.sessionId,
      url: result.url,
      paymentId: result.payment._id
    }, 'Payment session created successfully');

  } catch (error) {

    if (error.message === 'Invoice not found') {
      return errorResponse(res, 'Invoice not found', 404);
    }
    if (error.message === 'Unauthorized access to invoice') {
      return errorResponse(res, 'Unauthorized access to invoice', 403);
    }
    if (error.message === 'Invoice is already paid') {
      return errorResponse(res, 'Invoice is already paid', 400);
    }

    errorResponse(res, 'Failed to create payment session', 500);
  }
});

/**
 * Debug route to check webhook configuration
 * GET /api/payments/webhook-debug
 */
router.get('/webhook-debug', (req, res) => {
  res.json({
    message: 'Webhook endpoint is accessible',
    timestamp: new Date().toISOString(),
    webhookSecret: !!process.env.STRIPE_WEBHOOK_SECRET,
    environment: process.env.NODE_ENV,
    stripePublishableKey: !!process.env.STRIPE_PUBLISHABLE_KEY,
    stripeSecretKey: !!process.env.STRIPE_SECRET_KEY
  });
});

/**
 * Stripe webhook handler (no authentication required)
 * POST /api/payments/webhook
 */
router.post('/webhook', async (req, res) => {
  const sig = req.headers['stripe-signature'];
  const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET;


  if (!endpointSecret) {
    return res.status(500).json({ error: 'Webhook secret not configured' });
  }

  if (!sig) {
    return res.status(400).json({ error: 'No signature header' });
  }
  let event;
  try {
    // Use Stripe's direct webhook verification instead of custom wrapper
    event = stripe.webhooks.constructEvent(req.body, sig, endpointSecret);
  } catch (err) {
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  try {
    switch (event.type) {
      case 'checkout.session.completed':
        const session = event.data.object;
        const sessionId = session.id;


        // Handle successful payment
        try {
          const result = await stripeService.handlePaymentSuccess(sessionId);

          // Create RateHawk booking after successful payment
          try {
            const rateHawkService = require('../utils/RateHawkService');
            const Reservation = require('../models/Reservation');

            // Get the reservation to access book_hash
            const reservation = await Reservation.findById(result.reservation._id);

            if (reservation && reservation.hotel.rateHawkBookHash) {
              const bookingResult = await rateHawkService.createBooking(
                reservation.hotel.rateHawkBookHash,
                {
                  partner_order_id: result.invoice.invoiceId,
                  user_ip: session.customer_details?.address?.country || '0.0.0.0',
                  language: 'en'
                }
              );

              // Update reservation with RateHawk order ID
              if (bookingResult.success && bookingResult.order_id) {
                reservation.hotel.rateHawkOrderId = bookingResult.order_id;
                reservation.status = 'confirmed';
                await reservation.save();
                console.log('‚úÖ RateHawk booking created:', bookingResult.order_id);
              } else if (bookingResult.sandbox_mode) {
                console.log('‚ö†Ô∏è Sandbox mode: Booking simulated');
                reservation.status = 'confirmed'; // Still confirm in sandbox
                await reservation.save();
              }
            }
          } catch (rateHawkError) {
            console.error('‚ùå RateHawk booking failed:', rateHawkError.message);
            // Don't fail the payment webhook - booking can be created manually
          }

          // Send payment confirmation email
          try {
            await sendPaymentConfirmationEmail({
              email: result.invoice.clientEmail,
              name: result.invoice.clientName,
              invoice: result.invoice,
              payment: result.payment
            });
          } catch (emailError) {
          }

          // Send WhatsApp notification for payment confirmation
          try {
            // Get the booking details from the invoice
            const booking = {
              touristName: result.invoice.clientName,
              phone: result.invoice.clientPhone,
              hotel: { name: result.invoice.hotelName },
              checkIn: result.reservation?.checkIn,
              checkOut: result.reservation?.checkOut,
              duration: result.reservation?.duration,
              adults: result.reservation?.adults,
              children: result.reservation?.children
            };

            await whatsappService.sendBookingConfirmation(booking, result.payment);
          } catch (whatsappError) {
          }
        } catch (paymentError) {
        }
        break;

      case 'checkout.session.expired':
        const expiredSession = event.data.object;
        // Update payment status to expired
        try {
          await stripeService.handlePaymentFailure(expiredSession.id, 'Session expired');
        } catch (error) {
        }
        break;

      case 'payment_intent.payment_failed':
        const failedPayment = event.data.object;
        break;

      default:

    }    res.json({ received: true });
  } catch (err) {
    return res.status(500).send(`Webhook Processing Error: ${err.message}`);
  }
});

/**
 * Get payment status by session ID (no authentication required for redirect)
 * GET /api/payments/session/:sessionId
 */
router.get('/session/:sessionId', async (req, res) => {
  try {
    const { sessionId } = req.params;

    const status = await stripeService.getPaymentStatus(sessionId);

    successResponse(res, status, 'Payment status retrieved');
  } catch (error) {
    errorResponse(res, 'Failed to get payment status', 500);
  }
});

/**
 * Handle payment success callback (for backward compatibility)
 * POST /api/payments/success
 */
router.post('/success', protect, async (req, res) => {
  try {
    const { sessionId } = req.body;

    if (!sessionId) {
      return errorResponse(res, 'Session ID is required', 400);
    }

    const result = await stripeService.handlePaymentSuccess(sessionId);

    successResponse(res, {
      invoice: result.invoice,
      payment: result.payment
    }, 'Payment processed successfully');

  } catch (error) {
    errorResponse(res, 'Failed to process payment success', 500);
  }
});

/**
 * Handle payment failure
 * POST /api/payments/failure
 */
router.post('/failure', protect, async (req, res) => {
  try {
    const { sessionId, reason } = req.body;

    if (!sessionId) {
      return errorResponse(res, 'Session ID is required', 400);
    }

    const payment = await stripeService.handlePaymentFailure(sessionId, reason);

    successResponse(res, { payment }, 'Payment failure recorded');

  } catch (error) {
    errorResponse(res, 'Failed to handle payment failure', 500);
  }
});

/**
 * Get payment status
 * GET /api/payments/status/:sessionId
 */
router.get('/status/:sessionId', protect, async (req, res) => {
  try {
    const { sessionId } = req.params;

    const result = await stripeService.getPaymentStatus(sessionId);

    successResponse(res, result, 'Payment status retrieved successfully');

  } catch (error) {
    errorResponse(res, 'Failed to get payment status', 500);
  }
});

/**
 * Get user invoices with payment status
 * GET /api/payments/invoices
 */
router.get('/invoices', protect, async (req, res) => {
  try {
    const invoices = await Invoice.find({ user: req.user.id })
      .populate('reservation')
      .sort({ createdAt: -1 });

    // Get payment information for each invoice
    const invoicesWithPayments = await Promise.all(
      invoices.map(async (invoice) => {
        const payment = await Payment.findOne({ invoice: invoice._id });
        return {
          ...invoice.toObject(),
          paymentStatus: payment ? payment.status : 'unpaid'
        };
      })
    );

    successResponse(res, { invoices: invoicesWithPayments }, 'User invoices retrieved successfully');

  } catch (error) {
    errorResponse(res, 'Failed to get user invoices', 500);
  }
});

/**
 * Get user payments history
 * GET /api/payments/history
 */
router.get('/history', protect, async (req, res) => {
  try {
    const payments = await Payment.find({ user: req.user.id })
      .populate('invoice')
      .sort({ createdAt: -1 });

    successResponse(res, { payments }, 'Payment history retrieved successfully');

  } catch (error) {
    errorResponse(res, 'Failed to get payment history', 500);
  }
});

/**
 * Create payment intent for direct payment
 * POST /api/payments/create-intent
 */
router.post('/create-intent', protect, async (req, res) => {
  try {
    const { invoiceId } = req.body;

    if (!invoiceId) {
      return errorResponse(res, 'Invoice ID is required', 400);
    }

    const paymentIntent = await stripeService.createPaymentIntent(invoiceId, req.user.id);

    successResponse(res, {
      clientSecret: paymentIntent.client_secret,
      paymentIntentId: paymentIntent.id
    }, 'Payment intent created successfully');

  } catch (error) {
    console.error('Create payment intent error:', error);

    if (error.message === 'Invoice not found') {
      return errorResponse(res, 'Invoice not found', 404);
    }
    if (error.message === 'Unauthorized access to invoice') {
      return errorResponse(res, 'Unauthorized access to invoice', 403);
    }
    if (error.message === 'Invoice is already paid') {
      return errorResponse(res, 'Invoice is already paid', 400);
    }    errorResponse(res, 'Failed to create payment intent', 500);
  }
});

/**
 * Get individual invoice details
 * GET /api/payments/invoices/:id
 */
router.get('/invoices/:id', protect, async (req, res) => {
  try {
    const { id } = req.params;

    const invoice = await Invoice.findById(id)
      .populate('reservation')
      .populate('user', 'firstName lastName email');

    if (!invoice) {
      return errorResponse(res, 'Invoice not found', 404);
    }

    // Check if user owns this invoice
    if (invoice.user._id.toString() !== req.user.id) {
      return errorResponse(res, 'Unauthorized access to invoice', 403);
    }

    // Get payment information
    const payment = await Payment.findOne({ invoice: invoice._id })
      .sort({ createdAt: -1 });

    const invoiceWithPayment = {
      ...invoice.toObject(),
      payment: payment || null
    };

    successResponse(res, { invoice: invoiceWithPayment }, 'Invoice details retrieved successfully');

  } catch (error) {
    errorResponse(res, 'Failed to get invoice details', 500);
  }
});

/**
 * Download invoice receipt as PDF
 * GET /api/payments/invoices/:id/receipt
 */
router.get('/invoices/:id/receipt', protect, async (req, res) => {
  try {
    const { id } = req.params;

    const invoice = await Invoice.findById(id)
      .populate('reservation')
      .populate('user', 'firstName lastName email');

    if (!invoice) {
      return errorResponse(res, 'Invoice not found', 404);
    }

    // Check if user owns this invoice
    if (invoice.user._id.toString() !== req.user.id) {
      return errorResponse(res, 'Unauthorized access to invoice', 403);
    }

    // Check if invoice is paid
    if (invoice.paymentStatus !== 'paid') {
      return errorResponse(res, 'Receipt only available for paid invoices', 400);
    }

    // Get payment information
    const payment = await Payment.findOne({ invoice: invoice._id, status: 'completed' })
      .sort({ createdAt: -1 });

    if (!payment) {
      return errorResponse(res, 'Payment information not found', 404);
    }

    // Generate PDF receipt
    const PDFDocument = require('pdfkit');
    const doc = new PDFDocument({ margin: 50 });

    // Set response headers for PDF download
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="receipt-${invoice.invoiceNumber}.pdf"`);

    // Pipe the PDF to the response
    doc.pipe(res);

    // Add content to PDF
    // Header
    doc.fontSize(20).text('PAYMENT RECEIPT', 50, 50, { align: 'center' });
    doc.moveDown();

    // Company information (you can customize this)
    doc.fontSize(12)
       .text('Gaith Group', 50, 120)
       .text('Hotel Booking Services', 50, 135)
       .moveDown();

    // Receipt details
    doc.text(`Receipt #: ${invoice.invoiceNumber}`, 50, 170)
       .text(`Date: ${new Date(payment.processedAt || payment.createdAt).toLocaleDateString()}`, 50, 185)
       .text(`Customer: ${invoice.user.firstName} ${invoice.user.lastName}`, 50, 200)
       .text(`Email: ${invoice.user.email}`, 50, 215)
       .moveDown();

    // Invoice details
    doc.text('BOOKING DETAILS:', 50, 250)
       .text(`Hotel: ${invoice.hotelName}`, 50, 270)
       .text(`Guest: ${invoice.clientName}`, 50, 285)
       .text(`Email: ${invoice.clientEmail}`, 50, 300)
       .text(`Phone: ${invoice.clientPhone}`, 50, 315)
       .text(`Nationality: ${invoice.clientNationality}`, 50, 330)
       .moveDown();

    // Payment details
    doc.text('PAYMENT DETAILS:', 50, 370)
       .text(`Amount: ${invoice.amount.toFixed(2)} ${invoice.currency.toUpperCase()}`, 50, 390)
       .text(`Payment Method: ${payment.paymentMethod || 'Card'}`, 50, 405)
       .text(`Transaction ID: ${payment.stripePaymentIntentId || payment.transactionId || 'N/A'}`, 50, 420)
       .text(`Status: PAID`, 50, 435)
       .moveDown();

    // Footer
    doc.fontSize(10)
       .text('Thank you for choosing Gaith Group!', 50, 500, { align: 'center' })
       .text('This is an electronically generated receipt.', 50, 515, { align: 'center' });

    // Finalize the PDF
    doc.end();

  } catch (error) {
    errorResponse(res, 'Failed to generate receipt', 500);
  }
});

// ============================================
// KASHIER PAYMENT GATEWAY ROUTES
// ============================================

const kashierService = require('../utils/kashierService');
const rateHawkService = require('../utils/RateHawkService');
const { v4: uuidv4 } = require('uuid');

/**
 * Create Kashier payment session for booking
 * POST /api/payments/kashier/create-session
 */
router.post('/kashier/create-session', async (req, res) => {
  // Try to get user from token if provided (optional auth)
  const token = req.headers.authorization?.replace('Bearer ', '');
  let userId = null;
  let userNationality = 'US';

  if (token) {
    try {
      const jwt = require('jsonwebtoken');
      const User = require('../models/User');
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      const user = await User.findById(decoded.id).select('_id nationality');
      if (user) {
        userId = user._id;
        userNationality = user.nationality || 'US';
        console.log('üë§ Authenticated user for booking:', userId);
      }
    } catch (authError) {
      console.log('‚ö†Ô∏è Token invalid or expired, proceeding as guest booking');
    }
  }

  try {
    const {
      hotelId,
      hotelName,
      hotelAddress,
      hotelCity,
      hotelCountry,
      hotelRating,
      hotelImage,
      checkInDate,
      checkOutDate,
      numberOfGuests,
      roomType,
      guestName,
      guestEmail,
      guestPhone,
      totalPrice,
      currency,
      specialRequests,
      selectedRate,
      promoCode,
      discountAmount
    } = req.body;

    // Validate required fields
    if (!hotelId || !hotelName || !checkInDate || !checkOutDate || !selectedRate?.matchHash) {
      return errorResponse(res, 'Missing required booking information', 400);
    }

    if (!guestName || !guestEmail || !guestPhone) {
      return errorResponse(res, 'Guest information is required (name, email, phone)', 400);
    }

    if (!totalPrice || totalPrice <= 0) {
      return errorResponse(res, 'Valid payment amount is required', 400);
    }

    console.log('üéØ Creating Kashier payment session for booking...');
    console.log('   Hotel:', hotelName);
    console.log('   Amount:', totalPrice, currency);

    // Generate unique order ID
    const orderId = `GH-${Date.now()}-${uuidv4().slice(0, 8)}`;

    // Calculate nights
    const checkIn = new Date(checkInDate);
    const checkOut = new Date(checkOutDate);
    const nights = Math.ceil((checkOut - checkIn) / (1000 * 60 * 60 * 24));

    // Create pending reservation in database
    // Create pending reservation in database
    const reservation = new Reservation({
      user: userId, // Use the extracted userId (may be null for guests)
      touristName: guestName,
      email: guestEmail,
      phone: guestPhone,
      nationality: userNationality,
      hotel: {
        hotelId: hotelId, // Correctly save as hotelId (schema field)
        name: hotelName,
        address: hotelAddress || '',
        city: hotelCity || 'Unknown',
        country: hotelCountry || 'Unknown',
        rating: parseFloat(hotelRating) || 0,
        image: hotelImage || '',
        rateHawkMatchHash: selectedRate.matchHash,
        rateHawkBookHash: selectedRate.bookHash, // Save bookHash from frontend
        prebookPaymentAmount: selectedRate.prebookPaymentAmount, // Save prebook payment amount
        prebookPaymentCurrency: selectedRate.prebookPaymentCurrency // Save prebook payment currency
      },
      checkInDate: checkIn,
      checkOutDate: checkOut,
      numberOfNights: nights,
      numberOfRooms: 1,
      numberOfAdults: numberOfGuests || 2,
      numberOfChildren: 0,
      roomType: selectedRate.roomName || roomType || 'Standard Room',
      stayType: 'Leisure',
      meal: selectedRate.meal || 'nomeal',
      paymentMethod: 'kashier',
      specialRequests: specialRequests || '',
      status: 'pending_payment',
      totalPrice: totalPrice,
      currency: currency || 'EGP',
      kashierOrderId: orderId,
      ratehawkStatus: 'pending',
      promoCode: promoCode,
      discountAmount: discountAmount || 0
    });

    await reservation.save();
    console.log('üìù Pending reservation created:', reservation._id);
    if (promoCode) {
      console.log(`   üéüÔ∏è Promo code attached to reservation: ${promoCode}`);
      console.log(`   üí∞ Discount amount: ${discountAmount || 0}`);
    }

    // Create Kashier payment session
    let paymentSession;
    try {
      paymentSession = await kashierService.createPaymentSession({
        orderId,
        amount: parseFloat(totalPrice),
        currency: currency || 'EGP',
        customerEmail: guestEmail,
        customerReference: guestPhone,
        customerName: guestName, // Pass guest name for correct validation
        description: `${hotelName} - ${nights} night(s)`,
        metadata: {
          reservationId: reservation._id.toString(),
          hotelId,
          hotelName,
          checkIn: checkInDate,
          checkOut: checkOutDate,
          matchHash: selectedRate.matchHash
        }
      });
    } catch (paymentError) {
      console.error('‚ùå Kashier session creation error (Detailed):', JSON.stringify(paymentError, Object.getOwnPropertyNames(paymentError)));
      if (paymentError.response) {
         console.error('   Response Status:', paymentError.response.status);
         console.error('   Response Data:', JSON.stringify(paymentError.response.data, null, 2));
      }

      // Rollback reservation
      await Reservation.findByIdAndDelete(reservation._id);
      return errorResponse(res, `Failed to create payment session: ${paymentError.message}`, 500);
    }

    if (!paymentSession.success) {
      // Rollback reservation
      await Reservation.findByIdAndDelete(reservation._id);
      return errorResponse(res, 'Failed to create payment session', 500);
    }

    // Update reservation with session ID
    reservation.kashierSessionId = paymentSession.sessionId;
    await reservation.save();

    successResponse(res, {
      sessionId: paymentSession.sessionId,
      sessionUrl: paymentSession.sessionUrl,
      orderId: orderId,
      reservationId: reservation._id,
      expireAt: paymentSession.expireAt
    }, 'Payment session created successfully');

  } catch (error) {
    console.error('‚ùå Kashier session creation error:', error);
    errorResponse(res, error.message || 'Failed to create payment session', 500);
  }
});

/**
 * Kashier webhook handler
 * POST /api/payments/kashier/webhook
 */
router.post('/kashier/webhook', express.json(), async (req, res) => {
  console.log('üì® Kashier webhook received');
  console.log('   Body:', JSON.stringify(req.body, null, 2));

  try {
    const webhookData = req.body;

    // Extract payment information from webhook
    // Note: Adjust field names based on actual Kashier webhook payload structure
    const sessionId = webhookData.sessionId || webhookData._id;
    const status = webhookData.status;
    const orderId = webhookData.merchantOrderId || webhookData.paymentParams?.order || webhookData.metaData?.orderId;
    const amount = webhookData.amount || webhookData.paymentParams?.amount;

    console.log('   Session ID:', sessionId);
    console.log('   Status:', status);
    console.log('   Order ID:', orderId);

    // Check if payment is successful
    if (!kashierService.isPaymentSuccessful(status)) {
      console.log('‚ö†Ô∏è Payment not successful, status:', status);

      // Update reservation status if payment failed
      if (kashierService.isPaymentFailed(status) && orderId) {
        await Reservation.findOneAndUpdate(
          { kashierOrderId: orderId },
          { status: 'payment_failed', ratehawkStatus: 'cancelled' }
        );
      }

      return res.json({ received: true, processed: false });
    }

    // Find the reservation
    let reservation = await Reservation.findOne({
      $or: [
        { kashierOrderId: orderId },
        { kashierSessionId: sessionId }
      ]
    });

    if (!reservation) {
      console.error('‚ùå Reservation not found for order:', orderId);
      return res.status(404).json({ error: 'Reservation not found' });
    }

    // Check if already processed
    if (reservation.status === 'confirmed') {
      console.log('‚ö†Ô∏è Reservation already confirmed');
      return res.json({ received: true, processed: true });
    }

    console.log('‚úÖ Payment successful, creating RateHawk booking...');

    // Update reservation status to payment confirmed
    reservation.status = 'payment_confirmed';
    reservation.paymentConfirmedAt = new Date();
    await reservation.save();

    // Create Invoice and Payment records to record revenue
    await recordRevenue(reservation, {
      amount: parseFloat(amount) || reservation.totalPrice,
      currency: reservation.currency,
      sessionId: sessionId,
      orderId: orderId
    });

    // Handle Promo Code Usage
    if (reservation.promoCode) {
      try {
        console.log(`üéüÔ∏è Processing promo code: ${reservation.promoCode}`);
        console.log(`   Reservation ID: ${reservation._id}`);
        console.log(`   User ID: ${reservation.user}`);
        console.log(`   Discount Amount: ${reservation.discountAmount}`);

        const promoCodeDoc = await PromoCode.findOne({ code: reservation.promoCode });

        if (promoCodeDoc) {
          console.log(`   ‚úì Promo code found in database: ${promoCodeDoc.code}`);
          console.log(`   Current usage count: ${promoCodeDoc.usageCount}`);

          promoCodeDoc.usageCount += 1;
          promoCodeDoc.usedBy.push({
            user: reservation.user || null,
            bookingId: reservation._id,
            discountApplied: reservation.discountAmount || 0,
            usedAt: new Date()
          });

          await promoCodeDoc.save();
          console.log(`   ‚úÖ Promo code usage recorded successfully!`);
          console.log(`   New usage count: ${promoCodeDoc.usageCount}`);
          console.log(`   Total usedBy entries: ${promoCodeDoc.usedBy.length}`);
        } else {
          console.log(`   ‚ùå Promo code NOT found in database!`);
          console.log(`   Searched for code: "${reservation.promoCode}"`);
        }
      } catch (promoError) {
        console.error('‚ùå Error recording promo code usage:', promoError);
        console.error('   Error details:', promoError.message);
        console.error('   Stack:', promoError.stack);
        // Don't fail the whole payment flow for this
      }
    } else {
      console.log('   ‚ÑπÔ∏è No promo code applied to this reservation');
    }

    // Create RateHawk booking
    try {
      const matchHash = reservation.hotel.rateHawkMatchHash;

      if (!matchHash) {
        console.error('‚ùå No match hash found in reservation');
        reservation.ratehawkStatus = 'hash_missing';
        await reservation.save();
        return res.json({ received: true, processed: true, booking: false });
      }

      // Step 1: Prebook
      console.log('üîÑ Step 1: Prebooking...');
      const prebookResult = await rateHawkService.prebook(matchHash, 'en');

      if (!prebookResult.success || !prebookResult.book_hash) {
        console.error('‚ùå Prebook failed');
        reservation.ratehawkStatus = 'prebook_failed';
        await reservation.save();
        return res.json({ received: true, processed: true, booking: false });
      }

      const bookHash = prebookResult.book_hash;
      console.log('‚úÖ Prebook successful');

      // Step 2: Create booking form
      console.log('üìù Step 2: Creating booking form...');
      const partnerOrderId = orderId;

      const bookingFormResult = await rateHawkService.createBooking(bookHash, {
        partner_order_id: partnerOrderId,
        user_ip: req.ip || '0.0.0.0',
        language: 'en'
      });

      if (!bookingFormResult.success) {
        if (bookingFormResult.sandbox_mode) {
          console.log('‚ö†Ô∏è Sandbox mode - simulating booking');
          reservation.status = 'confirmed';
          reservation.ratehawkStatus = 'sandbox';
          await reservation.save();

          // Send confirmation email
          try {
            await sendPaymentConfirmationEmail({
              email: reservation.email,
              name: reservation.touristName,
              invoice: { hotelName: reservation.hotel.name, total: reservation.totalPrice },
              payment: { status: 'completed' }
            });
          } catch (emailError) {
            console.error('Email error:', emailError.message);
          }

          return res.json({ received: true, processed: true, booking: true, sandbox: true });
        }

        reservation.ratehawkStatus = 'booking_form_failed';
        await reservation.save();
        return res.json({ received: true, processed: true, booking: false });
      }

      // Step 3: Start booking with guest details
      console.log('üöÄ Step 3: Starting booking...');
      const nameParts = (reservation.touristName || 'Guest User').split(' ');
      const firstName = nameParts[0] || 'Guest';
      const lastName = nameParts.slice(1).join(' ') || 'User';

      await rateHawkService.startBooking(partnerOrderId, {
        user: {
          email: reservation.email,
          phone: reservation.phone,
          comment: reservation.specialRequests || ''
        },
        supplier_data: {
          first_name_original: firstName,
          last_name_original: lastName,
          phone: reservation.phone,
          email: reservation.email
        },
        rooms: [{
          guests: [{ first_name: firstName, last_name: lastName }]
        }],
        language: 'en',
        payment_type: {
          type: 'deposit',
          amount: Number(reservation.totalPrice).toFixed(2),
          currency_code: reservation.currency
        }
      });

      // Step 4: Poll for booking status
      console.log('‚è≥ Step 4: Checking booking status...');
      let bookingStatus;
      let attempts = 0;
      const maxAttempts = 10;

      while (attempts < maxAttempts) {
        await new Promise(resolve => setTimeout(resolve, 2000));
        bookingStatus = await rateHawkService.checkBookingStatus(partnerOrderId);
        console.log(`   Status check ${attempts + 1}/${maxAttempts}:`, bookingStatus.status);

        if (bookingStatus.status === 'ok' || bookingStatus.status === 'error') {
          break;
        }
        attempts++;
      }

      if (bookingStatus.status === 'ok') {
        console.log('‚úÖ RateHawk booking confirmed!');
        reservation.status = 'confirmed';
        reservation.ratehawkSystemOrderId = bookingStatus.order_id;
        // Keep ratehawkOrderId as the Partner Order ID (GH-...)
        reservation.ratehawkStatus = 'confirmed';
        await reservation.save();

        // Send confirmation email
        try {
          await sendPaymentConfirmationEmail({
            email: reservation.email,
            name: reservation.touristName,
            invoice: {
              hotelName: reservation.hotel.name,
              total: reservation.totalPrice,
              currency: reservation.currency
            },
            payment: { status: 'completed' }
          });
        } catch (emailError) {
          console.error('Email error:', emailError.message);
        }

        // Send WhatsApp notification
        try {
          await whatsappService.sendBookingConfirmation({
            touristName: reservation.touristName,
            phone: reservation.phone,
            hotel: { name: reservation.hotel.name },
            checkIn: reservation.checkInDate,
            checkOut: reservation.checkOutDate
          }, { status: 'completed', amount: reservation.totalPrice });
        } catch (whatsappError) {
          console.error('WhatsApp error:', whatsappError.message);
        }
      } else {
        console.error('‚ùå RateHawk booking failed:', bookingStatus.status);
        reservation.ratehawkStatus = 'booking_failed';
        await reservation.save();
      }

    } catch (rateHawkError) {
      console.error('‚ùå RateHawk booking error:', rateHawkError.message);
      reservation.ratehawkStatus = 'error';
      await reservation.save();
    }

    res.json({ received: true, processed: true });

  } catch (error) {
    console.error('‚ùå Webhook processing error:', error);
    res.status(500).json({ error: 'Webhook processing failed' });
  }
});

/**
 * Get Kashier payment status
 * GET /api/payments/kashier/status/:sessionId
 */
router.get('/kashier/status/:sessionId', async (req, res) => {
  try {
    const { sessionId } = req.params;

    if (!sessionId) {
      return errorResponse(res, 'Session ID is required', 400);
    }

    // Get payment status from Kashier
    const paymentStatus = await kashierService.getPaymentStatus(sessionId);

    // Also get reservation status
    const reservation = await Reservation.findOne({ kashierSessionId: sessionId });

    successResponse(res, {
      payment: paymentStatus,
      reservation: reservation ? {
        id: reservation._id,
        status: reservation.status,
        hotelName: reservation.hotel.name,
        checkIn: reservation.checkInDate,
        checkOut: reservation.checkOutDate,
        totalPrice: reservation.totalPrice,
        currency: reservation.currency,
        ratehawkStatus: reservation.ratehawkStatus
      } : null
    }, 'Payment status retrieved');

  } catch (error) {
    console.error('‚ùå Status check error:', error);
    errorResponse(res, error.message || 'Failed to get payment status', 500);
  }
});

/**
 * Get payment status by order ID
 * GET /api/payments/kashier/order/:orderId
 */
router.get('/kashier/order/:orderId', async (req, res) => {
  try {
    const { orderId } = req.params;

    if (!orderId) {
      return errorResponse(res, 'Order ID is required', 400);
    }

    // Get reservation by order ID
    const reservation = await Reservation.findOne({ kashierOrderId: orderId });

    if (!reservation) {
      return errorResponse(res, 'Order not found', 404);
    }

    // Get payment status from Kashier if we have session ID
    let paymentStatus = null;
    if (reservation.kashierSessionId) {
      try {
        // OPTIMIZATION: Only call Kashier API if reservation is still pending_payment
        // For confirmed/processing bookings, return cached status from reservation
        if (reservation.status === 'pending_payment') {
          paymentStatus = await kashierService.getPaymentStatus(reservation.kashierSessionId);

          // If payment is successful and reservation is still pending, update it and create RateHawk booking
          if (paymentStatus && kashierService.isPaymentSuccessful(paymentStatus.status)) {
            console.log('‚úÖ Payment confirmed, creating RateHawk booking...');
            reservation.status = 'payment_confirmed';
            reservation.paymentConfirmedAt = new Date();
            await reservation.save();

            // Record revenue
            await recordRevenue(reservation, {
              amount: reservation.totalPrice,
              currency: reservation.currency,
              sessionId: reservation.kashierSessionId,
              orderId: orderId
            });

            // Handle Promo Code Usage
            if (reservation.promoCode) {
              try {
                console.log(`üéüÔ∏è Processing promo code: ${reservation.promoCode}`);
                console.log(`   Reservation ID: ${reservation._id}`);
                console.log(`   User ID: ${reservation.user}`);
                console.log(`   Discount Amount: ${reservation.discountAmount}`);

                const promoCodeDoc = await PromoCode.findOne({ code: reservation.promoCode });

                if (promoCodeDoc) {
                  console.log(`   ‚úì Promo code found in database: ${promoCodeDoc.code}`);
                  console.log(`   Current usage count: ${promoCodeDoc.usageCount}`);

                  promoCodeDoc.usageCount += 1;
                  promoCodeDoc.usedBy.push({
                    user: reservation.user || null,
                    bookingId: reservation._id,
                    discountApplied: reservation.discountAmount || 0,
                    usedAt: new Date()
                  });

                  await promoCodeDoc.save();
                  console.log(`   ‚úÖ Promo code usage recorded successfully!`);
                  console.log(`   New usage count: ${promoCodeDoc.usageCount}`);
                  console.log(`   Total usedBy entries: ${promoCodeDoc.usedBy.length}`);
                } else {
                  console.log(`   ‚ùå Promo code NOT found in database!`);
                  console.log(`   Searched for code: "${reservation.promoCode}"`);
                }
              } catch (promoError) {
                console.error('‚ùå Error recording promo code usage:', promoError);
                console.error('   Error details:', promoError.message);
                // Don't fail the whole payment flow for this
              }
            } else {
              console.log('   ‚ÑπÔ∏è No promo code applied to this reservation');
            }

            // Trigger RateHawk booking asynchronously (only once when status changes from pending_payment)
            createRateHawkBooking(reservation, orderId).catch(err => {
              console.error('‚ùå Background RateHawk booking failed:', err.message);
            });
          }
        } else {
          // Return cached/mock payment status to avoid excessive Kashier API calls
          paymentStatus = {
            success: true,
            sessionId: reservation.kashierSessionId,
            status: 'PAID',
            amount: reservation.totalPrice,
            currency: reservation.currency,
            _cached: true // Indicator that this is cached data
          };
        }
      } catch (e) {
        console.warn('Could not fetch Kashier status:', e.message);
      }
    }

    successResponse(res, {
      orderId,
      payment: paymentStatus,
      reservation: {
        id: reservation._id,
        status: reservation.status,
        hotelName: reservation.hotel.name,
        checkIn: reservation.checkInDate,
        checkOut: reservation.checkOutDate,
        totalPrice: reservation.totalPrice || reservation.hotel.price || 0,
        currency: reservation.currency,
        ratehawkStatus: reservation.ratehawkStatus,
        ratehawkOrderId: reservation.ratehawkOrderId
      }
    }, 'Order status retrieved');

  } catch (error) {
    console.error('‚ùå Order status check error:', error);
    errorResponse(res, error.message || 'Failed to get order status', 500);
  }
});

module.exports = router;
