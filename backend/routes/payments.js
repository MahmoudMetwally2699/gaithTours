const express = require('express');
const { protect } = require('../middleware/auth');
const { successResponse, errorResponse } = require('../utils/helpers');
const stripeService = require('../utils/stripeService');
const Reservation = require('../models/Reservation');
const Payment = require('../models/Payment');
const Invoice = require('../models/Invoice');
const PromoCode = require('../models/PromoCode');
const User = require('../models/User');
const { sendPaymentConfirmationEmail } = require('../utils/emailService');
const whatsappService = require('../utils/whatsappService');
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

const router = express.Router();

/**
 * Helper function to record revenue (Invoice & Payment)
 */
async function recordRevenue(reservation, paymentData) {
  const Invoice = require('../models/Invoice');
  const Payment = require('../models/Payment');

  try {
    console.log('üí∞ Recording revenue for reservation:', reservation._id);

    // Check if invoice already exists
    const existingInvoice = await Invoice.findOne({ reservation: reservation._id });
    if (existingInvoice) {
      console.log('‚ö†Ô∏è Invoice already exists for reservation:', reservation._id);
      return true;
    }

    // 1. Create Invoice
    const invoice = new Invoice({
        // invoiceId will be generated by pre-validate hook
        user: reservation.user,
        reservation: reservation._id,
        clientName: reservation.touristName || 'Guest',
        clientEmail: reservation.email,
        clientPhone: reservation.phone,
        clientNationality: reservation.nationality || 'Unknown',
        hotelName: reservation.hotel.name,
        hotelAddress: reservation.hotel.address || reservation.hotel.name,
        amount: parseFloat(paymentData.amount) || reservation.totalPrice,
        currency: paymentData.currency || reservation.currency,
        status: 'paid',
        paymentStatus: 'paid',
        paymentDetails: {
          paidAt: new Date(),
          paymentMethod: 'kashier',
          transactionId: paymentData.sessionId
        }
    });

    await invoice.save();

    // 2. Create Payment
    const payment = new Payment({
        invoice: invoice._id,
        user: reservation.user,
        amount: invoice.amount,
        currency: invoice.currency,
        paymentMethod: 'kashier',
        status: 'completed',
        transactionId: paymentData.sessionId,
        merchantOrderId: paymentData.orderId,
        metadata: {
          reservationId: reservation._id,
          kashierOrderId: paymentData.orderId
        },
        processedAt: new Date()
    });
    await payment.save();

    console.log('‚úÖ Revenue recorded: Invoice & Payment created', invoice._id);
    return true;
  } catch (error) {
    console.error('‚ùå Failed to record revenue:', error);
    return false;
  }
}

/**
 * Helper function to create RateHawk booking after payment confirmation
 */
async function createRateHawkBooking(reservationParam, orderId) {
  const rateHawkService = require('../utils/RateHawkService');
  const Reservation = require('../models/Reservation');

  try {
    // Reload reservation from database to get latest data
    const reservation = await Reservation.findById(reservationParam._id);
    if (!reservation) {
      console.error('‚ùå Reservation not found');
      return;
    }

    const matchHash = reservation.hotel.rateHawkMatchHash;

    if (!matchHash) {
      console.error('‚ùå No match hash found in reservation');
      await Reservation.findByIdAndUpdate(reservation._id, { ratehawkStatus: 'hash_missing' });
      return;
    }

    // Check if we already have a book_hash from the prebook step (new flow)
    let bookHash = reservation.hotel.rateHawkBookHash;
    let depositAmount, depositCurrency;

    if (bookHash) {
      console.log('‚úÖ Found existing book_hash from prebook step:', bookHash);

      // Use stored prebook payment details if available
      depositAmount = reservation.hotel.prebookPaymentAmount;
      depositCurrency = reservation.hotel.prebookPaymentCurrency;

      if (depositAmount && depositCurrency) {
         console.log(`üí∞ Using pre-booked payment details: ${depositAmount} ${depositCurrency}`);
      }
    } else {
      // Fallback to old flow: Prebook now (if not done before payment)
      console.log('üîÑ Step 1: Prebooking (Legacy Flow)...');
      const prebookResult = await rateHawkService.prebook(matchHash, 'en');

      if (!prebookResult.success || !prebookResult.book_hash) {
        console.error('‚ùå Prebook failed');
        await Reservation.findByIdAndUpdate(reservation._id, { ratehawkStatus: 'prebook_failed' });
        return;
      }

      bookHash = prebookResult.book_hash;

      // extract details from fresh prebook
      const prebookPaymentType = prebookResult.data?.hotels?.[0]?.rates?.[0]?.payment_options?.payment_types?.[0];
      depositAmount = prebookPaymentType?.amount || Number(reservation.totalPrice).toFixed(2);
      depositCurrency = prebookPaymentType?.currency_code || reservation.currency || 'USD';

      console.log('‚úÖ Prebook successful');
    }

    // Step 2: Create booking form
    console.log('üìù Step 2: Creating booking form...');
    const bookingFormResult = await rateHawkService.createBooking(bookHash, {
      partner_order_id: orderId,
      user_ip: '0.0.0.0',
      language: 'en'
    });

    if (!bookingFormResult.success) {
      if (bookingFormResult.sandbox_mode) {
        console.log('‚ö†Ô∏è Sandbox mode - simulating booking');
        await Reservation.findByIdAndUpdate(reservation._id, {
          status: 'confirmed',
          ratehawkOrderId: orderId, // Use our internal ID as reference
          ratehawkStatus: 'sandbox'
        });

        // Send confirmation email
        try {
          await sendPaymentConfirmationEmail({
            email: reservation.email,
            name: reservation.touristName,
            invoice: { hotelName: reservation.hotel.name, total: reservation.totalPrice },
            payment: { status: 'completed' },
            booking: reservation
          });
        } catch (emailError) {
          console.error('Email error:', emailError.message);
        }
        return;
      }

      await Reservation.findByIdAndUpdate(reservation._id, { ratehawkStatus: 'booking_form_failed' });
      return;
    }

    // NOTE: Test hotel will now go through the full booking flow for certification
    // This logic was previously skipping the booking for test hotels - now removed

    // Ensure we have payment details for startBooking
    if (!depositAmount || !depositCurrency) {
       depositAmount = Number(reservation.totalPrice).toFixed(2);
       depositCurrency = reservation.currency || 'USD';
    }

    console.log('üí∞ Final Payment details for booking:');
    console.log(`   Deposit Amount: ${depositAmount} ${depositCurrency}`);

    // Step 3: Start booking with guest details
    console.log('üöÄ Step 3: Starting booking...');
    const nameParts = (reservation.touristName || 'Guest User').split(' ');
    const firstName = nameParts[0] || 'Guest';
    const lastName = nameParts.slice(1).join(' ') || 'User';

    await rateHawkService.startBooking(orderId, {
      user: {
        email: reservation.email,
        phone: reservation.phone,
        comment: reservation.specialRequests || ''
      },
      supplier_data: {
        first_name_original: firstName,
        last_name_original: lastName,
        phone: reservation.phone,
        email: reservation.email
      },
      rooms: [{
        guests: [{ first_name: firstName, last_name: lastName }]
      }],
      language: 'en',
      payment_type: {
        type: 'deposit',
        amount: depositAmount,  // Use prebook amount (USD)
        currency_code: depositCurrency  // Use prebook currency (USD)
      }
    });

    // Step 4: Poll for booking status
    console.log('‚è≥ Step 4: Checking booking status...');
    let bookingStatus;
    let attempts = 0;
    const maxAttempts = 6; // Reduced from 10 to 6

    while (attempts < maxAttempts) {
      await new Promise(resolve => setTimeout(resolve, 3000)); // Increased from 2s to 3s
      bookingStatus = await rateHawkService.checkBookingStatus(orderId);
      console.log(`   Status check ${attempts + 1}/${maxAttempts}:`, bookingStatus.status);

      if (bookingStatus.status === 'ok' || bookingStatus.status === 'error') {
        break;
      }
      attempts++;
    }

    if (bookingStatus.status === 'ok') {
      console.log('‚úÖ RateHawk booking confirmed!');
      await Reservation.findByIdAndUpdate(reservation._id, {
        status: 'confirmed',
        ratehawkOrderId: orderId, // Our partner order ID
        ratehawkSystemOrderId: bookingStatus.order_id, // RateHawk's system order ID
        ratehawkStatus: 'confirmed'
      });

      // Send confirmation email
      try {
        await sendPaymentConfirmationEmail({
          email: reservation.email,
          name: reservation.touristName,
          invoice: {
            hotelName: reservation.hotel.name,
            total: reservation.totalPrice,
            currency: reservation.currency
          },
          payment: { status: 'completed' },
          booking: reservation
        });
      } catch (emailError) {
        console.error('Email error:', emailError.message);
      }

      // Send WhatsApp notification
      try {
        await whatsappService.sendBookingConfirmation({
          touristName: reservation.touristName,
          phone: reservation.phone,
          hotel: { name: reservation.hotel.name },
          checkIn: reservation.checkInDate,
          checkOut: reservation.checkOutDate
        }, { status: 'completed', amount: reservation.totalPrice });
      } catch (whatsappError) {
        console.error('WhatsApp error:', whatsappError.message);
      }
    } else if (bookingStatus.status === 'error') {
      // Check if this is a test hotel
      console.log('üîç Booking failed with error status. Full Details:', JSON.stringify(bookingStatus, null, 2));
      console.log('üîç Hotel ID:', reservation.hotel.hotelId);

      if (reservation.hotel.hotelId === 'test_hotel_do_not_book' || reservation.hotel.name === 'Test Hotel Do Not Book') {
        // Test hotel - treat as sandbox mode
        console.log('‚ö†Ô∏è Test hotel detected - treating as successful sandbox booking');
        await Reservation.findByIdAndUpdate(reservation._id, {
          status: 'confirmed',
          ratehawkOrderId: orderId,
          ratehawkStatus: 'sandbox'
        });

        // Send confirmation email
        try {
          await sendPaymentConfirmationEmail({
            email: reservation.email,
          name: reservation.touristName,
          invoice: {
            hotelName: reservation.hotel.name,
            total: reservation.totalPrice,
            currency: reservation.currency
          },
          payment: { status: 'completed' }
        });
      } catch (emailError) {
        console.error('Email error:', emailError.message);
      }
    } else {
      console.error('‚ùå RateHawk booking failed (non-test hotel):', bookingStatus.status);
      await Reservation.findByIdAndUpdate(reservation._id, { ratehawkStatus: 'booking_failed' });
    }
    } else {
      console.error('‚ùå RateHawk booking failed:', bookingStatus.status);
      await Reservation.findByIdAndUpdate(reservation._id, { ratehawkStatus: 'booking_failed' });
    }

  } catch (error) {
    console.error('‚ùå RateHawk booking error:', error.message);
    await Reservation.findByIdAndUpdate(reservation._id, { ratehawkStatus: 'error' });
  }
}

/**
 * Create payment session for invoice
 * POST /api/payments/create-session
 */
router.post('/create-session', protect, async (req, res) => {
  try {
    const { invoiceId } = req.body;

    if (!invoiceId) {
      return errorResponse(res, 'Invoice ID is required', 400);
    }

    const result = await stripeService.createCheckoutSession(invoiceId, req.user.id);

    successResponse(res, {
      sessionId: result.sessionId,
      url: result.url,
      paymentId: result.payment._id
    }, 'Payment session created successfully');

  } catch (error) {

    if (error.message === 'Invoice not found') {
      return errorResponse(res, 'Invoice not found', 404);
    }
    if (error.message === 'Unauthorized access to invoice') {
      return errorResponse(res, 'Unauthorized access to invoice', 403);
    }
    if (error.message === 'Invoice is already paid') {
      return errorResponse(res, 'Invoice is already paid', 400);
    }

    errorResponse(res, 'Failed to create payment session', 500);
  }
});

/**
 * Debug route to check webhook configuration
 * GET /api/payments/webhook-debug
 */
router.get('/webhook-debug', (req, res) => {
  res.json({
    message: 'Webhook endpoint is accessible',
    timestamp: new Date().toISOString(),
    webhookSecret: !!process.env.STRIPE_WEBHOOK_SECRET,
    environment: process.env.NODE_ENV,
    stripePublishableKey: !!process.env.STRIPE_PUBLISHABLE_KEY,
    stripeSecretKey: !!process.env.STRIPE_SECRET_KEY
  });
});

/**
 * Stripe webhook handler (no authentication required)
 * POST /api/payments/webhook
 */
router.post('/webhook', async (req, res) => {
  const sig = req.headers['stripe-signature'];
  const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET;


  if (!endpointSecret) {
    return res.status(500).json({ error: 'Webhook secret not configured' });
  }

  if (!sig) {
    return res.status(400).json({ error: 'No signature header' });
  }
  let event;
  try {
    // Use Stripe's direct webhook verification instead of custom wrapper
    event = stripe.webhooks.constructEvent(req.body, sig, endpointSecret);
  } catch (err) {
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  try {
    switch (event.type) {
      case 'checkout.session.completed':
        const session = event.data.object;
        const sessionId = session.id;


        // Handle successful payment
        try {
          const result = await stripeService.handlePaymentSuccess(sessionId);

          // Create RateHawk booking after successful payment
          try {
            const rateHawkService = require('../utils/RateHawkService');
            const Reservation = require('../models/Reservation');

            // Get the reservation to access book_hash
            const reservation = await Reservation.findById(result.invoice.reservation);

            if (reservation && reservation.hotel.rateHawkBookHash) {
              const bookingResult = await rateHawkService.createBooking(
                reservation.hotel.rateHawkBookHash,
                {
                  partner_order_id: result.invoice.invoiceId,
                  user_ip: session.customer_details?.address?.country || '0.0.0.0',
                  language: 'en'
                }
              );

              // Update reservation with RateHawk order ID
              if (bookingResult.success && bookingResult.order_id) {
                reservation.hotel.rateHawkOrderId = bookingResult.order_id;
                reservation.status = 'confirmed';
                await reservation.save();
                console.log('‚úÖ RateHawk booking created:', bookingResult.order_id);
              } else if (bookingResult.sandbox_mode) {
                console.log('‚ö†Ô∏è Sandbox mode: Booking simulated');
                reservation.status = 'confirmed'; // Still confirm in sandbox
                await reservation.save();
              }
            }
          } catch (rateHawkError) {
            console.error('‚ùå RateHawk booking failed:', rateHawkError.message);
            // Don't fail the payment webhook - booking can be created manually
          }

          // Send payment confirmation email
          try {
            // Get full reservation details for email
            const fullReservation = await Reservation.findById(result.invoice.reservation);

            await sendPaymentConfirmationEmail({
              email: result.invoice.clientEmail,
              name: result.invoice.clientName,
              invoice: result.invoice,
              payment: result.payment,
              booking: fullReservation
            });
          } catch (emailError) {
          }

          // Send WhatsApp notification for payment confirmation
          try {
            // Get the booking details from the invoice
            const booking = {
              touristName: result.invoice.clientName,
              phone: result.invoice.clientPhone,
              hotel: { name: result.invoice.hotelName },
              checkIn: result.reservation?.checkIn,
              checkOut: result.reservation?.checkOut,
              duration: result.reservation?.duration,
              adults: result.reservation?.adults,
              children: result.reservation?.children
            };

            await whatsappService.sendBookingConfirmation(booking, result.payment);
          } catch (whatsappError) {
          }
        } catch (paymentError) {
        }
        break;

      case 'checkout.session.expired':
        const expiredSession = event.data.object;
        // Update payment status to expired
        try {
          await stripeService.handlePaymentFailure(expiredSession.id, 'Session expired');
        } catch (error) {
        }
        break;

      case 'payment_intent.payment_failed':
        const failedPayment = event.data.object;
        break;

      default:

    }    res.json({ received: true });
  } catch (err) {
    return res.status(500).send(`Webhook Processing Error: ${err.message}`);
  }
});

/**
 * Get payment status by session ID (no authentication required for redirect)
 * GET /api/payments/session/:sessionId
 */
router.get('/session/:sessionId', async (req, res) => {
  try {
    const { sessionId } = req.params;

    const status = await stripeService.getPaymentStatus(sessionId);

    successResponse(res, status, 'Payment status retrieved');
  } catch (error) {
    errorResponse(res, 'Failed to get payment status', 500);
  }
});

/**
 * Handle payment success callback (for backward compatibility)
 * POST /api/payments/success
 */
router.post('/success', protect, async (req, res) => {
  try {
    const { sessionId } = req.body;

    if (!sessionId) {
      return errorResponse(res, 'Session ID is required', 400);
    }

    const result = await stripeService.handlePaymentSuccess(sessionId);

    successResponse(res, {
      invoice: result.invoice,
      payment: result.payment
    }, 'Payment processed successfully');

  } catch (error) {
    errorResponse(res, 'Failed to process payment success', 500);
  }
});

/**
 * Handle payment failure
 * POST /api/payments/failure
 */
router.post('/failure', protect, async (req, res) => {
  try {
    const { sessionId, reason } = req.body;

    if (!sessionId) {
      return errorResponse(res, 'Session ID is required', 400);
    }

    const payment = await stripeService.handlePaymentFailure(sessionId, reason);

    successResponse(res, { payment }, 'Payment failure recorded');

  } catch (error) {
    errorResponse(res, 'Failed to handle payment failure', 500);
  }
});

/**
 * Get payment status
 * GET /api/payments/status/:sessionId
 */
router.get('/status/:sessionId', protect, async (req, res) => {
  try {
    const { sessionId } = req.params;

    const result = await stripeService.getPaymentStatus(sessionId);

    successResponse(res, result, 'Payment status retrieved successfully');

  } catch (error) {
    errorResponse(res, 'Failed to get payment status', 500);
  }
});

/**
 * Get user invoices with payment status
 * GET /api/payments/invoices
 */
router.get('/invoices', protect, async (req, res) => {
  try {
    const invoices = await Invoice.find({ user: req.user.id })
      .populate('reservation')
      .sort({ createdAt: -1 });

    // Get payment information for each invoice
    const invoicesWithPayments = await Promise.all(
      invoices.map(async (invoice) => {
        const payment = await Payment.findOne({ invoice: invoice._id });
        return {
          ...invoice.toObject(),
          paymentStatus: payment ? payment.status : 'unpaid'
        };
      })
    );

    successResponse(res, { invoices: invoicesWithPayments }, 'User invoices retrieved successfully');

  } catch (error) {
    errorResponse(res, 'Failed to get user invoices', 500);
  }
});

/**
 * Get user payments history
 * GET /api/payments/history
 */
router.get('/history', protect, async (req, res) => {
  try {
    const payments = await Payment.find({ user: req.user.id })
      .populate('invoice')
      .sort({ createdAt: -1 });

    successResponse(res, { payments }, 'Payment history retrieved successfully');

  } catch (error) {
    errorResponse(res, 'Failed to get payment history', 500);
  }
});

/**
 * Create payment intent for direct payment
 * POST /api/payments/create-intent
 */
router.post('/create-intent', protect, async (req, res) => {
  try {
    const { invoiceId } = req.body;

    if (!invoiceId) {
      return errorResponse(res, 'Invoice ID is required', 400);
    }

    const paymentIntent = await stripeService.createPaymentIntent(invoiceId, req.user.id);

    successResponse(res, {
      clientSecret: paymentIntent.client_secret,
      paymentIntentId: paymentIntent.id
    }, 'Payment intent created successfully');

  } catch (error) {
    console.error('Create payment intent error:', error);

    if (error.message === 'Invoice not found') {
      return errorResponse(res, 'Invoice not found', 404);
    }
    if (error.message === 'Unauthorized access to invoice') {
      return errorResponse(res, 'Unauthorized access to invoice', 403);
    }
    if (error.message === 'Invoice is already paid') {
      return errorResponse(res, 'Invoice is already paid', 400);
    }    errorResponse(res, 'Failed to create payment intent', 500);
  }
});

/**
 * Get individual invoice details
 * GET /api/payments/invoices/:id
 */
router.get('/invoices/:id', protect, async (req, res) => {
  try {
    const { id } = req.params;

    const invoice = await Invoice.findById(id)
      .populate('reservation')
      .populate('user', 'firstName lastName email');

    if (!invoice) {
      return errorResponse(res, 'Invoice not found', 404);
    }

    // Check if user owns this invoice
    if (invoice.user._id.toString() !== req.user.id) {
      return errorResponse(res, 'Unauthorized access to invoice', 403);
    }

    // Get payment information
    const payment = await Payment.findOne({ invoice: invoice._id })
      .sort({ createdAt: -1 });

    const invoiceWithPayment = {
      ...invoice.toObject(),
      payment: payment || null
    };

    successResponse(res, { invoice: invoiceWithPayment }, 'Invoice details retrieved successfully');

  } catch (error) {
    errorResponse(res, 'Failed to get invoice details', 500);
  }
});

/**
 * Download invoice receipt as PDF
 * GET /api/payments/invoices/:id/receipt
 */
router.get('/invoices/:id/receipt', protect, async (req, res) => {
  try {
    const { id } = req.params;
    const path = require('path');

    const invoice = await Invoice.findById(id)
      .populate('reservation')
      .populate('user', 'firstName lastName email');

    if (!invoice) {
      return errorResponse(res, 'Invoice not found', 404);
    }

    // Check if user owns this invoice
    if (invoice.user._id.toString() !== req.user.id) {
      return errorResponse(res, 'Unauthorized access to invoice', 403);
    }

    // Check if invoice is paid
    if (invoice.paymentStatus !== 'paid') {
      return errorResponse(res, 'Receipt only available for paid invoices', 400);
    }

    // Get payment information
    const payment = await Payment.findOne({ invoice: invoice._id, status: 'completed' })
      .sort({ createdAt: -1 });

    if (!payment) {
      return errorResponse(res, 'Payment information not found', 404);
    }

    // Use the centralized PDF generator with Arabic support
    const InvoicePDFGenerator = require('../utils/invoicePdfGenerator');
    const generator = new InvoicePDFGenerator();

    try {
      // Prepare invoice data for the generator
      const invoiceData = {
        invoiceId: invoice.invoiceNumber,
        createdAt: payment.processedAt || payment.createdAt,
        paymentStatus: 'PAID', // Always paid for receipts
        amount: invoice.amount,

        // Client info
        clientName: invoice.clientName,
        clientEmail: invoice.clientEmail,
        clientPhone: invoice.clientPhone,
        clientNationality: invoice.clientNationality,

        // Hotel info
        hotelName: invoice.hotelName,
        hotelAddress: invoice.hotelAddress,
        hotelCity: invoice.hotelCity,
        hotelImage: invoice.reservation?.hotel?.image || null,
        hotelId: invoice.reservation?.hotel?.hotelId || null,
        hotel: invoice.reservation?.hotel || null,

        // Booking info (if available)
        checkInDate: invoice.reservation ? invoice.reservation.checkInDate : null,
        checkOutDate: invoice.reservation ? invoice.reservation.checkOutDate : null,
        numberOfGuests: invoice.reservation ? (invoice.reservation.numberOfAdults || invoice.reservation.numberOfGuests) : null,

        // Payment details
        paymentMethod: payment.paymentMethod === 'kashier' ? 'Kashier' : (payment.paymentMethod || 'Card')
      };

      // Generate the PDF
      // Detect language - if client nationality is Egyptian or Arab country, maybe default to Ar?
      // For now, let's stick to English ('en') but with Arabic name support which we added to the generator
      // Or we can check if the name contains Arabic characters to decide the main language?
      // Let's use 'en' as the document language but our generator now supports Arabic values in English docs.
      const pdfBuffer = await generator.generateInvoicePDF(invoiceData, 'en');

      // Set response headers for PDF download
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="receipt-${invoice.invoiceNumber}.pdf"`);
      res.send(pdfBuffer);

    } catch (genError) {
      console.error('Invoice generation failed:', genError);
      throw genError;
    }
  } catch (error) {
    console.error('PDF generation error:', error);
    errorResponse(res, 'Failed to generate receipt', 500);
  }
});



// ============================================
// KASHIER PAYMENT GATEWAY ROUTES
// ============================================

const kashierService = require('../utils/kashierService');
const rateHawkService = require('../utils/RateHawkService');
const { v4: uuidv4 } = require('uuid');

/**
 * Create Kashier payment session for booking
 * POST /api/payments/kashier/create-session
 */
router.post('/kashier/create-session', async (req, res) => {
  // Try to get user from token if provided (optional auth)
  const token = req.headers.authorization?.replace('Bearer ', '');
  let userId = null;
  let userNationality = 'US';

  if (token) {
    try {
      const jwt = require('jsonwebtoken');
      const User = require('../models/User');
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      const user = await User.findById(decoded.id).select('_id nationality');
      if (user) {
        userId = user._id;
        userNationality = user.nationality || 'US';
        console.log('üë§ Authenticated user for booking:', userId);
      }
    } catch (authError) {
      console.log('‚ö†Ô∏è Token invalid or expired, proceeding as guest booking');
    }
  }

  try {
    const {
      hotelId,
      hotelHid, // Numeric hotel ID for fetching contact info
      hotelName,
      hotelAddress,
      hotelCity,
      hotelCountry,
      hotelRating,
      hotelImage,
      checkInDate,
      checkOutDate,
      numberOfGuests,
      roomType,
      guestName,
      guestEmail,
      guestPhone,
      totalPrice,
      currency,
      specialRequests,
      selectedRate,
      promoCode,
      discountAmount,
      loyaltyPointsToRedeem,
      loyaltyDiscount
    } = req.body;

    // Validate required fields
    if (!hotelId || !hotelName || !checkInDate || !checkOutDate || !selectedRate?.matchHash) {
      return errorResponse(res, 'Missing required booking information', 400);
    }

    if (!guestName || !guestEmail || !guestPhone) {
      return errorResponse(res, 'Guest information is required (name, email, phone)', 400);
    }

    if (!totalPrice || totalPrice <= 0) {
      return errorResponse(res, 'Valid payment amount is required', 400);
    }

    console.log('üéØ Creating Kashier payment session for booking...');
    console.log('   Hotel:', hotelName);
    console.log('   Amount:', totalPrice, currency);
    console.log('   isRefundable:', selectedRate.isRefundable);
    console.log('   freeCancellationBefore:', selectedRate.freeCancellationBefore);

    // Fetch hotel contact info (phone, email) from RateHawk API
    let hotelPhone = null;
    let hotelEmail = null;
    if (hotelId) {
      try {
        const contactInfo = await rateHawkService.getHotelContactInfo(hotelId);
        hotelPhone = contactInfo.phone;
        hotelEmail = contactInfo.email;
      } catch (contactError) {
        console.warn('‚ö†Ô∏è Could not fetch hotel contact info:', contactError.message);
      }
    }

    // Generate unique order ID
    const orderId = `GH-${Date.now()}-${uuidv4().slice(0, 8)}`;

    // Calculate nights
    const checkIn = new Date(checkInDate);
    const checkOut = new Date(checkOutDate);
    const nights = Math.ceil((checkOut - checkIn) / (1000 * 60 * 60 * 24));

    // Create pending reservation in database
    // Create pending reservation in database
    const reservation = new Reservation({
      user: userId, // Use the extracted userId (may be null for guests)
      touristName: guestName,
      email: guestEmail,
      phone: guestPhone,
      nationality: userNationality,
      hotel: {
        hotelId: hotelId, // Correctly save as hotelId (schema field)
        hid: hotelHid, // Save numeric hotel ID for future use
        name: hotelName,
        address: hotelAddress || '',
        city: hotelCity || 'Unknown',
        country: hotelCountry || 'Unknown',
        rating: parseFloat(hotelRating) || 0,
        image: hotelImage || '',
        phone: hotelPhone, // Hotel contact phone from API
        email: hotelEmail, // Hotel contact email from API
        rateHawkMatchHash: selectedRate.matchHash,
        rateHawkBookHash: selectedRate.bookHash, // Save bookHash from frontend
        prebookPaymentAmount: selectedRate.prebookPaymentAmount, // Save prebook payment amount
        prebookPaymentCurrency: selectedRate.prebookPaymentCurrency // Save prebook payment currency
      },
      checkInDate: checkIn,
      checkOutDate: checkOut,
      numberOfNights: nights,
      numberOfRooms: 1,
      numberOfAdults: numberOfGuests || 2,
      numberOfChildren: 0,
      roomType: selectedRate.roomName || roomType || 'Standard Room',
      stayType: 'Leisure',
      meal: selectedRate.meal || 'nomeal',
      paymentMethod: 'kashier',
      specialRequests: specialRequests || '',
      status: 'pending_payment',
      totalPrice: totalPrice,
      currency: currency || 'EGP',
      kashierOrderId: orderId,
      ratehawkStatus: 'pending',
      promoCode: promoCode,
      discountAmount: discountAmount || 0,
      // Loyalty points to be deducted after successful payment
      loyaltyPointsToRedeem: loyaltyPointsToRedeem || 0,
      loyaltyDiscount: loyaltyDiscount || 0,
      // Cancellation policy - important for Profile page display and refund eligibility
      isRefundable: selectedRate.isRefundable === true, // Only true if explicitly true
      freeCancellationBefore: selectedRate.freeCancellationBefore || null
    });

    await reservation.save();
    console.log('üìù Pending reservation created:', reservation._id);
    if (promoCode) {
      console.log(`   üéüÔ∏è Promo code attached to reservation: ${promoCode}`);
      console.log(`   üí∞ Discount amount: ${discountAmount || 0}`);
    }

    // Create Kashier payment session
    // Determine the correct amount to charge based on Kashier's currency
    const kashierCurrency = process.env.KASHIER_FORCE_TEST_CURRENCY || process.env.KASHIER_CURRENCY || 'USD';
    let kashierAmount = parseFloat(totalPrice);
    let displayCurrency = currency || 'SAR';

    // If Kashier is set to USD but frontend sent SAR, convert using prebook data
    // The prebook provides both show_amount (SAR) and amount (USD)
    // prebookPaymentAmount is the USD amount for 1 room base price
    if (kashierCurrency === 'USD' && displayCurrency !== 'USD' && selectedRate.prebookPaymentAmount) {
      const prebookUSD = parseFloat(selectedRate.prebookPaymentAmount);
      // Use prebookShowAmount (actual SAR from prebook) instead of selectedRate.price (which may have taxes extracted)
      const prebookSAR = parseFloat(selectedRate.prebookShowAmount) || parseFloat(selectedRate.price);

      if (prebookUSD > 0 && prebookSAR > 0) {
        // Calculate conversion rate from prebook data
        const sarToUsdRate = prebookUSD / prebookSAR;

        // Convert total price from SAR to USD
        kashierAmount = parseFloat((parseFloat(totalPrice) * sarToUsdRate).toFixed(2));

        console.log('üí± Currency conversion for Kashier:');
        console.log(`   Display Price: ${totalPrice} ${displayCurrency}`);
        console.log(`   Prebook show_amount: ${prebookSAR} SAR ‚Üí ${prebookUSD} USD`);
        console.log(`   Conversion Rate: 1 SAR = ${sarToUsdRate.toFixed(6)} USD`);
        console.log(`   Kashier Amount: ${kashierAmount} USD`);
      }
    }

    let paymentSession;
    try {
      paymentSession = await kashierService.createPaymentSession({
        orderId,
        amount: kashierAmount,
        currency: kashierCurrency, // Use Kashier's configured currency
        customerEmail: guestEmail,
        customerReference: guestPhone,
        customerName: guestName, // Pass guest name for correct validation
        description: `${hotelName} - ${nights} night(s)`,
        metadata: {
          reservationId: reservation._id.toString(),
          hotelId,
          hotelName,
          checkIn: checkInDate,
          checkOut: checkOutDate,
          matchHash: selectedRate.matchHash,
          originalAmount: totalPrice,
          originalCurrency: displayCurrency
        }
      });
    } catch (paymentError) {
      console.error('‚ùå Kashier session creation error (Detailed):', JSON.stringify(paymentError, Object.getOwnPropertyNames(paymentError)));
      if (paymentError.response) {
         console.error('   Response Status:', paymentError.response.status);
         console.error('   Response Data:', JSON.stringify(paymentError.response.data, null, 2));
      }

      // Rollback reservation
      await Reservation.findByIdAndDelete(reservation._id);
      return errorResponse(res, `Failed to create payment session: ${paymentError.message}`, 500);
    }

    if (!paymentSession.success) {
      // Rollback reservation
      await Reservation.findByIdAndDelete(reservation._id);
      return errorResponse(res, 'Failed to create payment session', 500);
    }

    // Update reservation with session ID and actual payment amount
    reservation.kashierSessionId = paymentSession.sessionId;
    reservation.actualPaymentAmount = kashierAmount; // Store actual USD amount for commission calculation
    reservation.actualPaymentCurrency = kashierCurrency;
    await reservation.save();

    successResponse(res, {
      sessionId: paymentSession.sessionId,
      sessionUrl: paymentSession.sessionUrl,
      orderId: orderId,
      reservationId: reservation._id,
      expireAt: paymentSession.expireAt
    }, 'Payment session created successfully');

  } catch (error) {
    console.error('‚ùå Kashier session creation error:', error);
    errorResponse(res, error.message || 'Failed to create payment session', 500);
  }
});

/**
 * Kashier webhook handler
 * POST /api/payments/kashier/webhook
 */
router.post('/kashier/webhook', express.json(), async (req, res) => {
  console.log('üì® Kashier webhook received');
  console.log('   Body:', JSON.stringify(req.body, null, 2));

  try {
    const webhookData = req.body;

    // Extract payment information from webhook
    // Note: Adjust field names based on actual Kashier webhook payload structure
    const sessionId = webhookData.sessionId || webhookData._id;
    const status = webhookData.status;
    const orderId = webhookData.merchantOrderId || webhookData.paymentParams?.order || webhookData.metaData?.orderId;
    const amount = webhookData.amount || webhookData.paymentParams?.amount;

    console.log('   Session ID:', sessionId);
    console.log('   Status:', status);
    console.log('   Order ID:', orderId);

    // Check if payment is successful
    if (!kashierService.isPaymentSuccessful(status)) {
      console.log('‚ö†Ô∏è Payment not successful, status:', status);

      // Update reservation status if payment failed
      if (kashierService.isPaymentFailed(status) && orderId) {
        await Reservation.findOneAndUpdate(
          { kashierOrderId: orderId },
          { status: 'payment_failed', ratehawkStatus: 'cancelled' }
        );
      }

      return res.json({ received: true, processed: false });
    }

    // Find the reservation
    let reservation = await Reservation.findOne({
      $or: [
        { kashierOrderId: orderId },
        { kashierSessionId: sessionId }
      ]
    });

    if (!reservation) {
      console.error('‚ùå Reservation not found for order:', orderId);
      return res.status(404).json({ error: 'Reservation not found' });
    }

    // Check if already processed
    if (reservation.status === 'confirmed') {
      console.log('‚ö†Ô∏è Reservation already confirmed');
      return res.json({ received: true, processed: true });
    }

    console.log('‚úÖ Payment successful, creating RateHawk booking...');

    // Update reservation status to payment confirmed
    reservation.status = 'payment_confirmed';
    reservation.paymentConfirmedAt = new Date();
    await reservation.save();

    // Create Invoice and Payment records to record revenue
    await recordRevenue(reservation, {
      amount: parseFloat(amount) || reservation.totalPrice,
      currency: reservation.currency,
      sessionId: sessionId,
      orderId: orderId
    });

    // Handle Promo Code Usage
    if (reservation.promoCode) {
      try {
        console.log(`üéüÔ∏è Processing promo code: ${reservation.promoCode}`);
        console.log(`   Reservation ID: ${reservation._id}`);
        console.log(`   User ID: ${reservation.user}`);
        console.log(`   Discount Amount: ${reservation.discountAmount}`);

        const promoCodeDoc = await PromoCode.findOne({ code: reservation.promoCode });

        if (promoCodeDoc) {
          console.log(`   ‚úì Promo code found in database: ${promoCodeDoc.code}`);
          console.log(`   Current usage count: ${promoCodeDoc.usageCount}`);

          promoCodeDoc.usageCount += 1;
          promoCodeDoc.usedBy.push({
            user: reservation.user || null,
            bookingId: reservation._id,
            discountApplied: reservation.discountAmount || 0,
            usedAt: new Date()
          });

          await promoCodeDoc.save();
          console.log(`   ‚úÖ Promo code usage recorded successfully!`);
          console.log(`   New usage count: ${promoCodeDoc.usageCount}`);
          console.log(`   Total usedBy entries: ${promoCodeDoc.usedBy.length}`);

          // Record referral booking if this is a referral code
          if (promoCodeDoc.type === 'referral') {
            console.log(`   üéÅ Recording referral booking for partner: ${promoCodeDoc.partnerInfo?.name}`);
            // Use actualPaymentAmount (USD) for commission calculation, not display currency
            const commissionBaseAmount = reservation.actualPaymentAmount || (reservation.totalPrice + (reservation.discountAmount || 0));
            await promoCodeDoc.recordReferralBooking(
              reservation._id,
              commissionBaseAmount, // Use actual USD payment amount
              reservation.discountAmount || 0
            );
            console.log(`   ‚úÖ Referral booking recorded!`);
            console.log(`   Commission base amount: ${commissionBaseAmount} ${reservation.actualPaymentCurrency || reservation.currency}`);
            console.log(`   Total commission earned: ${promoCodeDoc.totalCommissionEarned}`);
          }
        } else {
          console.log(`   ‚ùå Promo code NOT found in database!`);
          console.log(`   Searched for code: "${reservation.promoCode}"`);
        }
      } catch (promoError) {
        console.error('‚ùå Error recording promo code usage:', promoError);
        console.error('   Error details:', promoError.message);
        console.error('   Stack:', promoError.stack);
        // Don't fail the whole payment flow for this
      }
    } else {
      console.log('   ‚ÑπÔ∏è No promo code applied to this reservation');
    }

    // Handle Loyalty Points Redemption
    if (reservation.loyaltyPointsToRedeem && reservation.loyaltyPointsToRedeem > 0 && reservation.user) {
      try {
        console.log(`üéÅ Processing loyalty points redemption: ${reservation.loyaltyPointsToRedeem} points`);
        console.log(`   User ID: ${reservation.user}`);
        console.log(`   Loyalty Discount: ${reservation.loyaltyDiscount}`);

        const User = require('../models/User');
        const LoyaltySettings = require('../models/LoyaltySettings');

        const user = await User.findById(reservation.user);

        if (user && user.loyaltyPoints >= reservation.loyaltyPointsToRedeem) {
          const previousPoints = user.loyaltyPoints;
          user.loyaltyPoints -= reservation.loyaltyPointsToRedeem;

          // Recalculate tier
          user.loyaltyTier = await LoyaltySettings.calculateTier(user.loyaltyPoints);

          await user.save();

          console.log(`   ‚úÖ Loyalty points deducted successfully!`);
          console.log(`   Points: ${previousPoints} ‚Üí ${user.loyaltyPoints}`);
          console.log(`   New tier: ${user.loyaltyTier}`);
        } else {
          console.log(`   ‚ö†Ô∏è Could not deduct points - insufficient balance or user not found`);
        }
      } catch (loyaltyError) {
        console.error('‚ùå Error deducting loyalty points:', loyaltyError);
        console.error('   Error details:', loyaltyError.message);
        // Don't fail the whole payment flow for this
      }
    } else {
      console.log('   ‚ÑπÔ∏è No loyalty points to redeem for this reservation');
    }

    // Award Loyalty Points for the booking
    if (reservation.user) {
      try {
        const User = require('../models/User');
        const LoyaltySettings = require('../models/LoyaltySettings');

        const loyaltySettings = await LoyaltySettings.getSettings();

        if (loyaltySettings.isEnabled) {
          // Use booking amount for points calculation
          const bookingAmount = reservation.totalPrice || 0;
          const bookingCurrency = reservation.currency || 'USD';

          // Convert to base currency (simplified - using USD equivalent)
          // For proper implementation, use actual exchange rates
          const amountInUSD = bookingCurrency === 'USD' ? bookingAmount : bookingAmount;

          // Calculate points earned using configurable formula: "For every $X spent, earn Y points"
          const dollarsRequired = loyaltySettings.earningDollarsRequired || 1;
          const pointsToEarn = loyaltySettings.pointsPerDollar || 1;
          const pointsEarned = Math.floor(amountInUSD / dollarsRequired) * pointsToEarn;

          if (pointsEarned > 0) {
            const user = await User.findById(reservation.user);
            if (user) {
              const previousPoints = user.loyaltyPoints || 0;
              user.loyaltyPoints = previousPoints + pointsEarned;
              user.totalSpent = (user.totalSpent || 0) + amountInUSD;

              // Recalculate tier
              user.loyaltyTier = await LoyaltySettings.calculateTier(user.loyaltyPoints);

              await user.save();

              console.log(`üéÅ Loyalty: Awarded ${pointsEarned} points to ${user.email} (${amountInUSD} ${bookingCurrency} / ${dollarsRequired} √ó ${pointsToEarn})`);
              console.log(`   Points: ${previousPoints} ‚Üí ${user.loyaltyPoints}`);
              console.log(`   Tier: ${user.loyaltyTier}`);
            }
          }
        }
      } catch (loyaltyError) {
        console.error('‚ùå Error awarding loyalty points:', loyaltyError);
        // Don't fail the whole payment flow for this
      }
    }

    // Create RateHawk booking
    try {
      const matchHash = reservation.hotel.rateHawkMatchHash;

      if (!matchHash) {
        console.error('‚ùå No match hash found in reservation');
        reservation.ratehawkStatus = 'hash_missing';
        await reservation.save();
        return res.json({ received: true, processed: true, booking: false });
      }

      // Step 1: Prebook
      console.log('üîÑ Step 1: Prebooking...');
      const prebookResult = await rateHawkService.prebook(matchHash, 'en');

      if (!prebookResult.success || !prebookResult.book_hash) {
        console.error('‚ùå Prebook failed');
        reservation.ratehawkStatus = 'prebook_failed';
        await reservation.save();
        return res.json({ received: true, processed: true, booking: false });
      }

      const bookHash = prebookResult.book_hash;
      console.log('‚úÖ Prebook successful');

      // Step 2: Create booking form
      console.log('üìù Step 2: Creating booking form...');
      const partnerOrderId = orderId;

      const bookingFormResult = await rateHawkService.createBooking(bookHash, {
        partner_order_id: partnerOrderId,
        user_ip: req.ip || '0.0.0.0',
        language: 'en'
      });

      if (!bookingFormResult.success) {
        if (bookingFormResult.sandbox_mode) {
          console.log('‚ö†Ô∏è Sandbox mode - simulating booking');
          reservation.status = 'confirmed';
          reservation.ratehawkStatus = 'sandbox';
          await reservation.save();

          // Send confirmation email
          try {
            await sendPaymentConfirmationEmail({
              email: reservation.email,
              name: reservation.touristName,
              invoice: { hotelName: reservation.hotel.name, total: reservation.totalPrice },
              payment: { status: 'completed' }
            });
          } catch (emailError) {
            console.error('Email error:', emailError.message);
          }

          return res.json({ received: true, processed: true, booking: true, sandbox: true });
        }

        reservation.ratehawkStatus = 'booking_form_failed';
        await reservation.save();
        return res.json({ received: true, processed: true, booking: false });
      }

      // Step 3: Start booking with guest details
      console.log('üöÄ Step 3: Starting booking...');
      const nameParts = (reservation.touristName || 'Guest User').split(' ');
      const firstName = nameParts[0] || 'Guest';
      const lastName = nameParts.slice(1).join(' ') || 'User';

      await rateHawkService.startBooking(partnerOrderId, {
        user: {
          email: reservation.email,
          phone: reservation.phone,
          comment: reservation.specialRequests || ''
        },
        supplier_data: {
          first_name_original: firstName,
          last_name_original: lastName,
          phone: reservation.phone,
          email: reservation.email
        },
        rooms: [{
          guests: [{ first_name: firstName, last_name: lastName }]
        }],
        language: 'en',
        payment_type: {
          type: 'deposit',
          amount: Number(reservation.totalPrice).toFixed(2),
          currency_code: reservation.currency
        }
      });

      // Step 4: Poll for booking status
      console.log('‚è≥ Step 4: Checking booking status...');
      let bookingStatus;
      let attempts = 0;
      const maxAttempts = 10;

      while (attempts < maxAttempts) {
        await new Promise(resolve => setTimeout(resolve, 2000));
        bookingStatus = await rateHawkService.checkBookingStatus(partnerOrderId);
        console.log(`   Status check ${attempts + 1}/${maxAttempts}:`, bookingStatus.status);

        if (bookingStatus.status === 'ok' || bookingStatus.status === 'error') {
          break;
        }
        attempts++;
      }

      if (bookingStatus.status === 'ok') {
        console.log('‚úÖ RateHawk booking confirmed!');
        reservation.status = 'confirmed';
        reservation.ratehawkSystemOrderId = bookingStatus.order_id;
        // Keep ratehawkOrderId as the Partner Order ID (GH-...)
        reservation.ratehawkStatus = 'confirmed';
        await reservation.save();

        // Send confirmation email
        try {
          await sendPaymentConfirmationEmail({
            email: reservation.email,
            name: reservation.touristName,
            invoice: {
              hotelName: reservation.hotel.name,
              total: reservation.totalPrice,
              currency: reservation.currency
            },
            payment: { status: 'completed' },
            booking: reservation
          });
        } catch (emailError) {
          console.error('Email error:', emailError.message);
        }

        // Send WhatsApp notification
        try {
          await whatsappService.sendBookingConfirmation({
            touristName: reservation.touristName,
            phone: reservation.phone,
            hotel: { name: reservation.hotel.name },
            checkIn: reservation.checkInDate,
            checkOut: reservation.checkOutDate
          }, { status: 'completed', amount: reservation.totalPrice });
        } catch (whatsappError) {
          console.error('WhatsApp error:', whatsappError.message);
        }
      } else {
        console.error('‚ùå RateHawk booking failed:', bookingStatus.status);
        reservation.ratehawkStatus = 'booking_failed';
        await reservation.save();
      }

    } catch (rateHawkError) {
      console.error('‚ùå RateHawk booking error:', rateHawkError.message);
      reservation.ratehawkStatus = 'error';
      await reservation.save();
    }

    res.json({ received: true, processed: true });

  } catch (error) {
    console.error('‚ùå Webhook processing error:', error);
    res.status(500).json({ error: 'Webhook processing failed' });
  }
});

/**
 * Get Kashier payment status
 * GET /api/payments/kashier/status/:sessionId
 */
router.get('/kashier/status/:sessionId', async (req, res) => {
  try {
    const { sessionId } = req.params;

    if (!sessionId) {
      return errorResponse(res, 'Session ID is required', 400);
    }

    // Get payment status from Kashier
    const paymentStatus = await kashierService.getPaymentStatus(sessionId);

    // Also get reservation status
    const reservation = await Reservation.findOne({ kashierSessionId: sessionId });

    successResponse(res, {
      payment: paymentStatus,
      reservation: reservation ? {
        id: reservation._id,
        status: reservation.status,
        hotelName: reservation.hotel.name,
        checkIn: reservation.checkInDate,
        checkOut: reservation.checkOutDate,
        totalPrice: reservation.totalPrice,
        currency: reservation.currency,
        ratehawkStatus: reservation.ratehawkStatus
      } : null
    }, 'Payment status retrieved');

  } catch (error) {
    console.error('‚ùå Status check error:', error);
    errorResponse(res, error.message || 'Failed to get payment status', 500);
  }
});

/**
 * Get payment status by order ID
 * GET /api/payments/kashier/order/:orderId
 */
router.get('/kashier/order/:orderId', async (req, res) => {
  try {
    const { orderId } = req.params;

    if (!orderId) {
      return errorResponse(res, 'Order ID is required', 400);
    }

    // Get reservation by order ID
    const reservation = await Reservation.findOne({ kashierOrderId: orderId });

    if (!reservation) {
      return errorResponse(res, 'Order not found', 404);
    }

    // Get payment status from Kashier if we have session ID
    let paymentStatus = null;
    if (reservation.kashierSessionId) {
      try {
        // OPTIMIZATION: Only call Kashier API if reservation is still pending_payment
        // For confirmed/processing bookings, return cached status from reservation
        if (reservation.status === 'pending_payment') {
          paymentStatus = await kashierService.getPaymentStatus(reservation.kashierSessionId);

          // If payment is successful and reservation is still pending, update it and create RateHawk booking
          if (paymentStatus && kashierService.isPaymentSuccessful(paymentStatus.status)) {
            console.log('‚úÖ Payment confirmed, creating RateHawk booking...');
            reservation.status = 'payment_confirmed';
            reservation.paymentConfirmedAt = new Date();
            await reservation.save();

            // Record revenue
            await recordRevenue(reservation, {
              amount: reservation.totalPrice,
              currency: reservation.currency,
              sessionId: reservation.kashierSessionId,
              orderId: orderId
            });

            // Handle Promo Code Usage
            if (reservation.promoCode) {
              try {
                console.log(`üéüÔ∏è Processing promo code: ${reservation.promoCode}`);
                console.log(`   Reservation ID: ${reservation._id}`);
                console.log(`   User ID: ${reservation.user}`);
                console.log(`   Discount Amount: ${reservation.discountAmount}`);

                const promoCodeDoc = await PromoCode.findOne({ code: reservation.promoCode });

                if (promoCodeDoc) {
                  console.log(`   ‚úì Promo code found in database: ${promoCodeDoc.code}`);
                  console.log(`   Current usage count: ${promoCodeDoc.usageCount}`);

                  promoCodeDoc.usageCount += 1;
                  promoCodeDoc.usedBy.push({
                    user: reservation.user || null,
                    bookingId: reservation._id,
                    discountApplied: reservation.discountAmount || 0,
                    usedAt: new Date()
                  });

                  await promoCodeDoc.save();
                  console.log(`   ‚úÖ Promo code usage recorded successfully!`);
                  console.log(`   New usage count: ${promoCodeDoc.usageCount}`);
                  console.log(`   Total usedBy entries: ${promoCodeDoc.usedBy.length}`);

                  // Record referral booking if this is a referral code
                  if (promoCodeDoc.type === 'referral') {
                    console.log(`   üéÅ Recording referral booking for partner: ${promoCodeDoc.partnerInfo?.name}`);
                    // Use actualPaymentAmount (USD) for commission calculation, not display currency
                    const commissionBaseAmount = reservation.actualPaymentAmount || (reservation.totalPrice + (reservation.discountAmount || 0));
                    await promoCodeDoc.recordReferralBooking(
                      reservation._id,
                      commissionBaseAmount, // Use actual USD payment amount
                      reservation.discountAmount || 0
                    );
                    console.log(`   ‚úÖ Referral booking recorded!`);
                    console.log(`   Commission base amount: ${commissionBaseAmount} ${reservation.actualPaymentCurrency || reservation.currency}`);
                    console.log(`   Total commission earned: ${promoCodeDoc.totalCommissionEarned}`);
                  }
                } else {
                  console.log(`   ‚ùå Promo code NOT found in database!`);
                  console.log(`   Searched for code: "${reservation.promoCode}"`);
                }
              } catch (promoError) {
                console.error('‚ùå Error recording promo code usage:', promoError);
                console.error('   Error details:', promoError.message);
                // Don't fail the whole payment flow for this
              }
            } else {
              console.log('   ‚ÑπÔ∏è No promo code applied to this reservation');
            }

            // Award Loyalty Points for the booking
            if (reservation.user) {
              try {
                const User = require('../models/User');
                const LoyaltySettings = require('../models/LoyaltySettings');

                const loyaltySettings = await LoyaltySettings.getSettings();
                console.log(`üéÅ Loyalty check: isEnabled=${loyaltySettings.isEnabled}, user=${reservation.user}`);

                if (loyaltySettings.isEnabled) {
                  const bookingAmount = reservation.totalPrice || 0;
                  const bookingCurrency = reservation.currency || 'USD';
                  const amountInUSD = bookingCurrency === 'USD' ? bookingAmount : bookingAmount;

                  const dollarsRequired = loyaltySettings.earningDollarsRequired || 1;
                  const pointsToEarn = loyaltySettings.pointsPerDollar || 1;
                  const pointsEarned = Math.floor(amountInUSD / dollarsRequired) * pointsToEarn;

                  console.log(`   Booking: ${bookingAmount} ${bookingCurrency}, dollarsRequired=${dollarsRequired}, pointsToEarn=${pointsToEarn}, earned=${pointsEarned}`);

                  if (pointsEarned > 0) {
                    const user = await User.findById(reservation.user);
                    if (user) {
                      const previousPoints = user.loyaltyPoints || 0;
                      user.loyaltyPoints = previousPoints + pointsEarned;
                      user.totalSpent = (user.totalSpent || 0) + amountInUSD;
                      user.loyaltyTier = await LoyaltySettings.calculateTier(user.loyaltyPoints);
                      await user.save();

                      console.log(`üéÅ Loyalty: Awarded ${pointsEarned} points to ${user.email}`);
                      console.log(`   Points: ${previousPoints} ‚Üí ${user.loyaltyPoints}`);
                    } else {
                      console.log(`   ‚ö†Ô∏è User not found for ID: ${reservation.user}`);
                    }
                  } else {
                    console.log(`   ‚ö†Ô∏è No points to award (pointsEarned=${pointsEarned})`);
                  }
                } else {
                  console.log(`   ‚ö†Ô∏è Loyalty program is DISABLED`);
                }
              } catch (loyaltyError) {
                console.error('‚ùå Error awarding loyalty points:', loyaltyError);
              }
            } else {
              console.log(`   ‚ö†Ô∏è No user attached to reservation`);
            }

            // Trigger RateHawk booking asynchronously (only once when status changes from pending_payment)
            createRateHawkBooking(reservation, orderId).catch(err => {
              console.error('‚ùå Background RateHawk booking failed:', err.message);
            });
          }
        } else {
          // Return cached/mock payment status to avoid excessive Kashier API calls
          paymentStatus = {
            success: true,
            sessionId: reservation.kashierSessionId,
            status: 'PAID',
            amount: reservation.totalPrice,
            currency: reservation.currency,
            _cached: true // Indicator that this is cached data
          };
        }
      } catch (e) {
        console.warn('Could not fetch Kashier status:', e.message);
      }
    }

    successResponse(res, {
      orderId,
      payment: paymentStatus,
      reservation: {
        id: reservation._id,
        status: reservation.status,
        hotelName: reservation.hotel.name,
        checkIn: reservation.checkInDate,
        checkOut: reservation.checkOutDate,
        totalPrice: reservation.totalPrice || reservation.hotel.price || 0,
        currency: reservation.currency,
        ratehawkStatus: reservation.ratehawkStatus,
        ratehawkOrderId: reservation.ratehawkOrderId
      }
    }, 'Order status retrieved');

  } catch (error) {
    console.error('‚ùå Order status check error:', error);
    errorResponse(res, error.message || 'Failed to get order status', 500);
  }
});

module.exports = router;
